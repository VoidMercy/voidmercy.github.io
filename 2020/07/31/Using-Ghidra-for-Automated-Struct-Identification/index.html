<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Using Ghidra for Automated Struct Identification | Hexo</title>
    <meta name="author" content="John Doe" />
    <meta name="keywords" content="" />
    <meta name="description" content="Over the course of my internship, I worked on projects that mainly involve binary analysis. One of which uses Ghidra to develop a plugin that automates struct identification of function parameters. The main idea behind my approach is using static ana" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

    
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    
<link rel="stylesheet" href="/css/style.css">


    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
<meta name="generator" content="Hexo 7.0.0"></head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">Hexo</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">Posts</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">About</span>
            </a>
        
            <a class="nav-item" href="/contact">
                <span class="nav-text">Contact</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://voidmercy.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Background"><span class="toc-number">1.</span> <span class="toc-text">Background</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Techniques"><span class="toc-number">2.</span> <span class="toc-text">Techniques</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbolic-Analysis"><span class="toc-number">2.1.</span> <span class="toc-text">Symbolic Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intermediate-Language"><span class="toc-number">2.2.</span> <span class="toc-text">Intermediate Language</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Dependency"><span class="toc-number">2.3.</span> <span class="toc-text">Data Dependency</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Implementation"><span class="toc-number">3.</span> <span class="toc-text">Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#P-Code-Function-Depth-First-Search"><span class="toc-number">3.1.</span> <span class="toc-text">P-Code Function Depth-First Search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P-Code-Symbolic-Execution"><span class="toc-number">3.2.</span> <span class="toc-text">P-Code Symbolic Execution</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mapping-Varnodes-to-Symbolic-Expressions"><span class="toc-number">3.3.</span> <span class="toc-text">Mapping Varnodes to Symbolic Expressions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CALL-opcode-Interprocedural-Analysis"><span class="toc-number">3.4.</span> <span class="toc-text">CALL opcode - Interprocedural Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Struct-Interpolation"><span class="toc-number">3.5.</span> <span class="toc-text">Struct Interpolation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Results"><span class="toc-number">4.</span> <span class="toc-text">Results</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Future-Work"><span class="toc-number">5.</span> <span class="toc-text">Future Work</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Conclusion"><span class="toc-number">6.</span> <span class="toc-text">Conclusion</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Using Ghidra for Automated Struct Identification
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://voidmercy.github.io/2020/07/31/Using-Ghidra-for-Automated-Struct-Identification/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2020-07-31T21:41:46.000Z" itemprop="datePublished">2020-07-31</time>
</a>

            

        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p><br>Over the course of my internship, I worked on projects that mainly involve binary analysis. One of which uses Ghidra to develop a plugin that automates struct identification of function parameters. The main idea behind my approach is using static analysis to symbolically interpret Ghidra’s P-Code representation of binaries. Every data value will be represented in relation to a function’s arguments. By obtaining a list of store and load instructions performed on data offsetted from a function’s arguments, we can infer the members and member sizes of the argument’s struct.</p>
<p>This post will discuss in detail the techniques used, the background behind each technique, and the implementation.</p>
<span id="more"></span>

<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>Ghidra is a binary reverse engineering tool developed by the National Security Agency (NSA). Binary reverse engineering is the process of understanding the behavior of compiled binary code. To aid reverse engineers, Ghidra is a disassembler and decompiler that is able to recover high level C-like representation pseudocode from assembly, allowing reverse engineers to understand code much more easily. Ghidra also supports decompilation for over 16 architectures, which is an edge for Ghidra compared to its main competitor, IDA Pro Hex-Rays. A few examples of these architectures are: x86, x86-64, MIPS, and ARM.</p>
<p>One great feature about Ghidra is its <a target="_blank" rel="noopener" href="https://ghidra.re/ghidra_docs/api/index.html">API</a>. Almost everything Ghidra does in the backend is accessible through Ghidra’s API. Additionally, the documentation is well done, allowing me to easily understand the functions available through the API.</p>
<h1 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h1><p>My approach involves performing static symbolic analysis on the data dependency graph from Ghidra’s IL (Intermediate Language) representation of all architectures. As a result, this plugin supports all architectures supported by Ghidra, and new architectures can be supported by implementing a lifter to lift the desired architecture into Ghidra’s IL, which also known as P-Code.</p>
<h2 id="Symbolic-Analysis"><a href="#Symbolic-Analysis" class="headerlink" title="Symbolic Analysis"></a>Symbolic Analysis</h2><p>Symbolic analysis has recently become popular, and a few symbolic analysis engines exist, such as <a target="_blank" rel="noopener" href="http://angr.io/api-doc/index.html">angr</a>. The main idea behind symbolic analysis is execute the program while treating each unknown as a variable. Usually these unknowns are the inputs to the program or function. Then, any values derived from that value will be a symbolic expression, rather than a concrete value. Let’s look at an example.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val1 = get_integer();</span><br><span class="line"><span class="type">int</span> val2 = val1 * <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> val3 = val2 + <span class="number">1337</span>;</span><br></pre></td></tr></table></figure>

<p>In this pseudocode, the only unknown input is <code>val1</code>. This value is stored symbolically. So, when the second line is executed, the value stored in <code>val2</code> will be <code>val1 * 5</code>. Similarly the symbolic expressions continue the propagate, and <code>val3</code> will be <code>val1 * 5 + 1337</code>.</p>
<p>One major issue with symbolic execution is the path explosion problem. This occurs when a branch in the code is hit. Because symbolic execution seeks to explore the entire program, both branches will be taken, and the condition (and its inverse) for that branch will be imposed on both states after the branch. This is sound in theory, however many issues arise when you upscale the size of the program. Each conditional that is introduced will exponentially increase the possible paths that can be taken in the code.</p>
<h2 id="Intermediate-Language"><a href="#Intermediate-Language" class="headerlink" title="Intermediate Language"></a>Intermediate Language</h2><p>Often times, we like to find the similarities in many different ideas, and abstractize them into one, for ease of understanding. This is precisely the idea behind intermediate languages. Because there exists numerous architectures out there - x86, ARM, MIPS - it isn’t ideal to deal with each type individually. An intermediate language representation is created to be able to support and generalize many different architectures. Each architecture can them be transformed into this intermediate language and be treated as one problem.</p>
<p>Ghidra’s intermediate language is called P-Code. Every single instruction in P-Code is well documented <a target="_blank" rel="noopener" href="https://ghidra.re/courses/languages/html/pcoderef.html">here</a> and <a target="_blank" rel="noopener" href="https://ghidra.re/courses/languages/html/additionalpcode.html">here</a>. Ghidra’s disassembly interface has an option to enable the P-Code representation of instructions, and can be found here:</p>
<p><img src="/static/20200731/pcode_toggle.png"></p>
<p>To give an idea of what P-Code looks like, here are a few examples of instructions from different architectures and their respective P-Code representation.</p>
<p>x86 <code>add</code> instruction:</p>
<p><img src="/static/20200731/pcode_example_1.png"></p>
<p>MIPS <code>addiu</code> instruction:</p>
<p><img src="/static/20200731/pcode_example_2.png"></p>
<p>ARM <code>add</code> instruction:</p>
<p><img src="/static/20200731/pcode_example_3.png"></p>
<p>With the basic set of instructions defined by P-Code specifications, all of the instructions from various architectures can be accurately modeled.</p>
<h2 id="Data-Dependency"><a href="#Data-Dependency" class="headerlink" title="Data Dependency"></a>Data Dependency</h2><p>Data dependency is a useful abstract idea for representing code. The idea is that each instruction changes some sort of state in the program, whether it is a register, or some stack variable. This changed state may then be used elsewhere in the program, often times the next few instructions. We say that whenever the state affected by instruction A is used by another state B that is affected by some instruction, then B depends on A. Thus, there is a directed edge from A to B. The combination of all such dependencies in a program is the data dependency graph.</p>
<p>Obtaining the data dependency graph of the assembly representation is more complicated since each architecture has different register models. First, we have to understand how Ghidra does data dependency.</p>
<p>Ghidra’s implementation of a data dependency graph uses P-Code representation. Ghidra represents each “state” (register, variable, or memory), as a node in the graph and is called <a target="_blank" rel="noopener" href="https://ghidra.re/ghidra_docs/api/ghidra/program/model/pcode/Varnode.html">Varnode</a>. The children of a node can be fetched with <code>getDescendants()</code>, and the parent of a node with <code>getDef()</code>. You might be wondering why the parent is singular - that is why does each node only ever have one parent. It makes sense that multiple values may affect another value. However this is because Ghidra uses <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> (single static assignment) form.</p>
<p>SSA representation is a well studied idea in compiler theory. This is best demonstrated through an example. Let’s use the following example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// x1</span></span><br><span class="line">x = x + <span class="number">3</span>; <span class="comment">// x2</span></span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">1337</span>) &#123; <span class="comment">// x4</span></span><br><span class="line">	x++; <span class="comment">// x3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are a few things to note here. First, take a look at lines 1 and 2. Intuitively we may think that it is reasonable for x to only be a single node here that gets assigned values twice. However, SSA requires each node to be assigned a value once. Therefore, according to SSA, we create different “versions” of x each time it gets assigned a new value. Hence the comments denoting different x’s. In Ghidra terminology, there would be two <code>Varnodes</code> on lines 1 and 2.</p>
<p>The second thing to note is on line 3. Say we are looking at the loop condition <code>x &lt; 1337</code>. Which Varnode is the x here derived from? There are actually two Varnode possibilities in this case - the <code>x</code> on line <code>2</code> and the <code>x</code> on line <code>4</code>. Both of these nodes are the parent of the <code>x</code> in the loop condition. In this case, SSA defines what is called a <code>phi node</code>, which represents the merging of multiple nodes. Ghidra defines this as a <code>multiequal</code> instruction, whose definition can be found <a target="_blank" rel="noopener" href="https://ghidra.re/courses/languages/html/additionalpcode.html">here</a>. The x86-64 assembly of this example is shown below, with comments representing different “versions” of x.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">mov     [rbp+x], <span class="number">0</span> <span class="comment">// x1</span></span><br><span class="line">add     [rbp+x], <span class="number">3</span> <span class="comment">// x2</span></span><br><span class="line">jmp     condition</span><br><span class="line">loop:</span><br><span class="line">add     [rbp+x], <span class="number">1</span> <span class="comment">// x3</span></span><br><span class="line">condition:</span><br><span class="line">cmp     [rbp+x], <span class="number">538</span>h <span class="comment">// x4</span></span><br><span class="line">jle     loop</span><br><span class="line">mov     eax, <span class="number">0</span></span><br><span class="line">pop     rbp</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p>The respective data dependency graph would look like:</p>
<p><img src="/static/20200731/dd2.png"></p>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>Using a combination of these techniques, we can identify the structs of function parameters. The main idea is that for us to infer the members of a struct, some store and load will be performed at some offset on the struct pointer. To infer the size of the member, either the size of the load&#x2F;store can be used (byte, word, dword, qword), or if two contiguous members are accessed, we know to draw a boundary between the two accessed members. I chose to implement the Ghidra plugin in Python, which is ran through Ghidra’s Jython interpreter.</p>
<p>To implement this, symbolic execution can be performed on the data dependency nodes whose root nodes are the function parameters. The data dependency graph can then be traversed with DFS, and all stores and loads performed are recorded. Conveniently, all stores and loads in any architecture are abstractized into the <code>STORE</code> and <code>LOAD</code> P-Code instructions.</p>
<h2 id="P-Code-Function-Depth-First-Search"><a href="#P-Code-Function-Depth-First-Search" class="headerlink" title="P-Code Function Depth-First Search"></a>P-Code Function Depth-First Search</h2><p>Because we are analyzing function parameters, we can consider functions to be isolated from each other. One issue you may be thinking about is the few globally shared structs that are used between functions. However, these cases are rare and much more difficult to accommodate for, as analysis will have to be performed on the entire program, so we consider this out of scope.</p>
<p>To access the varnodes of a function, Ghidra defines a <code>HighFunction</code> class that abstractizes a function into P-Code representation. Function parameter varnodes can then be fetched from here. Additionally, the data dependency graph for which we want to do DFS is easy to traverse with the <code>	getDescendants()</code> function from <code>Varnode</code>. The DFS looks something like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverseForward</span>(<span class="params">cur, depth, pci, visited</span>):</span><br><span class="line">	<span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	children = cur.getDescendants()</span><br><span class="line">	<span class="keyword">for</span> child <span class="keyword">in</span> children:</span><br><span class="line">		pci.process(child, depth)</span><br><span class="line">		<span class="keyword">if</span> child.getOutput() <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> child.getOutput() <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">			visited.add(child.getOutput())</span><br><span class="line">			traverseForward(child.getOutput(), depth + <span class="number">1</span>, pci, visited)</span><br></pre></td></tr></table></figure>

<p>Using this, we can traverse each P-Code instruction.</p>
<h2 id="P-Code-Symbolic-Execution"><a href="#P-Code-Symbolic-Execution" class="headerlink" title="P-Code Symbolic Execution"></a>P-Code Symbolic Execution</h2><p>Now, we have to implement the actual symbolic execution. This involves writing a P-Code interpreter for each P-Code instruction, and storing the abstract symbolic expressions, with the symbolic variables being function parameters. The code for this is implemented in the <code>PCodeInterpreter</code> class, most of which is self explanatory. Symbolic expressions are stored in a tree structure, which is defined by the <code>Node</code> class. Let’s take an example of a symbolic expression and look at how this would be stored.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">uint32_t</span>)(*((<span class="type">char</span>*)(ARG1 + <span class="number">0x8</span>)))</span><br></pre></td></tr></table></figure>

<p>In this case, the expression would be stored as:</p>
<p><img src="/static/20200731/expression.png"></p>
<p>Really, it’s just a variant of a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_expression_tree">binary expression tree</a>.</p>
<p>Now let’s look at the P-Code interpreter. Take the <code>INT_ADD</code> opcode as an example:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">int_add</span>(<span class="params">self, inputs, output</span>):</span><br><span class="line">	<span class="keyword">assert</span> <span class="built_in">len</span>(inputs) == <span class="number">2</span> <span class="keyword">and</span> output <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">	a = inputs[<span class="number">0</span>]</span><br><span class="line">	b = inputs[<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">if</span> (a.isConstant() <span class="keyword">and</span> b.isConstant()) <span class="keyword">or</span> a.isConstant():</span><br><span class="line">		<span class="keyword">raise</span> Exception(<span class="string">&quot;INT_ADD error&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> self.lookup_node(a):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> self.lookup_node(b):</span><br><span class="line">			self.store_node(output, i.add(j))</span><br></pre></td></tr></table></figure>

<p>The implementation of most P-Code opcodes are simple to understand. In the <code>INT_ADD</code> case, there are two parameters, and parameter one is usually a <code>Varnode</code>, and parameter two might be a constant or <code>Varnode</code> added to parameter one. Most of the P-Code opcodes are implemented in a similar manner. You may wonder why the code loops through <code>a</code> and <code>b</code>. This is because there can be multiple paths in the code, resulting in multiple possible values, due to phi-nodes. Thus, each possibility and combination must be considered as a possible value a <code>Varnode</code> holds.</p>
<p>There are a few functions relevant to P-Code interpretation that require heavy consideration: <code>lookup_node</code>, <code>store_node</code>, and the <code>CALL</code> opcode. The first two functions respectively handle the mapping between Ghidra’s <code>Varnodes</code> and the <code>Node</code> symbolic expression tree representation. The <code>CALL</code> opcode handles the interprocedural analysis.</p>
<h2 id="Mapping-Varnodes-to-Symbolic-Expressions"><a href="#Mapping-Varnodes-to-Symbolic-Expressions" class="headerlink" title="Mapping Varnodes to Symbolic Expressions"></a>Mapping Varnodes to Symbolic Expressions</h2><p>First, let’s take a look at <code>store_node</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store_node</span>(<span class="params">self, varnode, nodeobj</span>):</span><br><span class="line">	<span class="keyword">if</span> varnode <span class="keyword">not</span> <span class="keyword">in</span> self.nodes:</span><br><span class="line">		self.nodes[varnode] = []</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">hash</span>(nodeobj) <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">hash</span>, self.nodes[varnode]):</span><br><span class="line">		self.nodes[varnode].append(nodeobj)</span><br></pre></td></tr></table></figure>

<p>This is rather simple to understand, but is required for understanding <code>lookup_node</code>. Essentially, the <code>self.nodes</code> dictionary stores a mapping between a Ghidra <code>Varnode</code> object and a symbolic expression <code>Node</code> object. Now here is <code>lookup_node</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lookup_node</span>(<span class="params">self, varnode</span>):</span><br><span class="line">	<span class="comment"># Detect cycle</span></span><br><span class="line">	<span class="keyword">if</span> varnode <span class="keyword">in</span> self.cycle_exec:</span><br><span class="line">		self.cycle_exec[varnode] += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> varnode <span class="keyword">in</span> self.cycle_exec <span class="keyword">and</span> self.cycle_exec[varnode] &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> varnode <span class="keyword">not</span> <span class="keyword">in</span> self.nodes:</span><br><span class="line">			self.store_node(varnode, Node((<span class="string">&quot;CYCLE&quot;</span>, varnode), <span class="literal">None</span>, <span class="literal">None</span>, varnode.getSize()))</span><br><span class="line">		<span class="keyword">return</span> self.nodes[varnode]</span><br><span class="line">	<span class="keyword">if</span> varnode.isConstant():</span><br><span class="line">		<span class="comment"># create constant node</span></span><br><span class="line">		<span class="keyword">return</span> [Node(varnode, <span class="literal">None</span>, <span class="literal">None</span>, varnode.getSize())]</span><br><span class="line">	<span class="keyword">elif</span> varnode.isAddress():</span><br><span class="line">		<span class="keyword">return</span> [Node(varnode, <span class="literal">None</span>, <span class="literal">None</span>, varnode.getSize())]</span><br><span class="line">	<span class="keyword">elif</span> varnode <span class="keyword">not</span> <span class="keyword">in</span> self.nodes <span class="keyword">or</span> varnode <span class="keyword">in</span> self.cycle_exec:</span><br><span class="line">		<span class="comment"># We have to detect cycles here, by temporarily storing &quot;CYCLE&quot;, and if the returned value is &quot;CYCLE&quot;, we know there is cycle</span></span><br><span class="line">		<span class="comment"># self.store_node(varnode, cycle_node)</span></span><br><span class="line">		<span class="keyword">if</span> varnode <span class="keyword">not</span> <span class="keyword">in</span> self.cycle_exec:</span><br><span class="line">			self.cycle_exec[varnode] = <span class="number">0</span></span><br><span class="line">		self.get_node_definition(varnode)</span><br><span class="line">		<span class="keyword">if</span> self.cycle_exec[varnode] == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">del</span> self.cycle_exec[varnode]</span><br><span class="line">		<span class="keyword">return</span> self.lookup_node(varnode)</span><br><span class="line">	<span class="comment"># Prune</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(self.nodes[varnode]) &gt; NODE_LIMIT:</span><br><span class="line">		self.nodes[varnode] = self.nodes[varnode][:NODE_LIMIT]</span><br><span class="line">	<span class="keyword">return</span> self.nodes[varnode]</span><br></pre></td></tr></table></figure>

<p>Normally, <code>lookup_node</code> is quite simple. If the <code>Varnode</code> represents a constant or address location, we convert that into a <code>Node</code> object. Then, if it’s in the <code>self.nodes</code> mapping dictionary, we simply return the mapping. However, there are two main issues: (1) when we try to lookup a node that is not defined yet and (2) when there is a cycle due to phi-nodes.</p>
<p>You might wonder why (1) happens. This is best represented by the following graph:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">uint32_t</span>* arg0, <span class="type">uint32_t</span>* arg1)</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> temp = *(arg0 + <span class="number">0x8</span>);</span><br><span class="line">	<span class="type">uint32_t</span> temp2 = *(arg1 + <span class="number">0x10</span>);</span><br><span class="line">	<span class="type">uint32_t</span> temp3 = temp + temp2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/static/20200731/undefined.png"></p>
<p>Because we are traversing in DFS manner from only the function parameters, we may require nodes that have not yet been encountered. In this case, we are finding the definition of temp3 which depends on temp2, yet temp2 is not yet defined, since DFS has not reached that node. To solve this, we must perform backwards traverse from the node that isn’t defined, which we need to be defined. This is the <code>get_node_definition</code> function under <code>PCodeInterpreter</code>. This function recursively traverses the parent of each node until a full definition can be defined, with function arguments as the base case.</p>
<p>You also might wonder why (2) happens. Let’s go back to a previous example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">mov     [rbp+x], <span class="number">0</span> <span class="comment">// x1</span></span><br><span class="line">add     [rbp+x], <span class="number">3</span> <span class="comment">// x2</span></span><br><span class="line">jmp     condition</span><br><span class="line">loop:</span><br><span class="line">add     [rbp+x], <span class="number">1</span> <span class="comment">// x3</span></span><br><span class="line">condition:</span><br><span class="line">cmp     [rbp+x], <span class="number">538</span>h <span class="comment">// x4</span></span><br><span class="line">jle     loop</span><br><span class="line">mov     eax, <span class="number">0</span></span><br><span class="line">pop     rbp</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p><img src="/static/20200731/dd2.png"></p>
<p>When we encounter the phi-node, usually we want to get the definitions for all the inputs, so that we retain all the possible paths moving forward. However, when we try to resolve <code>x4</code>, we must first resolve the phi-node, whose inputs include <code>x3</code>. We traverse <code>x3</code>‘s dependency graph, we find that we end up in a loop. <code>x3</code> depends on the phi-node, and the phi-node depends on <code>x3</code>. This is what the <code>self.cycle_exec</code> dictionary and <code>Node((&quot;CYCLE&quot;, varnode), None, None, varnode.getSize())</code> solves. It both identifies the cycle, and terminates the cycles. This is an important idea used for array identification, which will be explained during struct interpolation.</p>
<h2 id="CALL-opcode-Interprocedural-Analysis"><a href="#CALL-opcode-Interprocedural-Analysis" class="headerlink" title="CALL opcode - Interprocedural Analysis"></a>CALL opcode - Interprocedural Analysis</h2><p>Next, let’s consider the <code>CALL</code> opcode. Interprocedural analysis is extremely important, because one of the members of the struct (from the function parameter we are analyzing) may be passed into another function. Then, in the other function, many stores and loads may be performed on that. We need to retain and capture that information. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>* a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125; test;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">(test* input)</span> &#123;</span><br><span class="line">	function2(input-&gt;a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function2</span><span class="params">(<span class="type">char</span>* a)</span> &#123;</span><br><span class="line">	*(a) = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this case, we have to analyze function2 to infer that <code>input-&gt;a</code> is of type <code>char*</code>.</p>
<p>Additionally, a function can return a return value, that is then used later on. Stores and loads may be performed on that value. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>* a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125; test;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">(test* input)</span> &#123;</span><br><span class="line">	<span class="type">char</span>* c = function2(input);</span><br><span class="line">	*(c) = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">function2</span><span class="params">(test* input)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> input-&gt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this example, we need to know that the return value of function2 is <code>input-&gt;a</code> to be able to infer that the store, <code>*(c) = &#39;C&#39;;</code>, indicates that <code>input-&gt;a</code> is a <code>char*</code>.</p>
<p>To support these ideas, two types of analysis is required. One is forward analysis, which is what we have been doing - performing DFS on function parameters and recording stores and loads. The second is backwards analysis. This is looking at all the possible return value varnodes from a function, and obtaining their symbolic definitions in relation to function parameters. Luckily backwards analysis is very easily implemented as a variation of forwards analysis through <code>lookup_node</code> on the return varnodes, and setting the definitions for the function arguments as base case. Recursion for the win!</p>
<p>To improve performance, the results of forward analysis is cached, since each store and load performed on a function is in relation to the function parameters. So, we can cache these results, and replace the function parameters with the respective inputs during P-Code interpretation. Likewise, backwards analysis can also be cached the same way.</p>
<p>Now, with the theory behind mapping varnodes to symbolic expressions and interprocedural analysis, we can obtain all the stores and loads by logging the symbolic expression each <code>STORE</code> and <code>LOAD</code> instruction acts on. An few examples of these include:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] STORE: <span class="number">0010089</span>a (<span class="type">uint32_t</span>)(*(ARG0 + (<span class="type">const</span>, <span class="number">0x1</span>, <span class="number">8</span>) * (<span class="type">const</span>, <span class="number">0x4</span>, <span class="number">8</span>)))</span><br><span class="line">[*] STORE: <span class="number">00100984</span> (<span class="type">uint32_t</span>)(*(ARG0 + (<span class="type">const</span>, <span class="number">0x1</span>, <span class="number">8</span>) * (<span class="type">const</span>, <span class="number">0x4</span>, <span class="number">8</span>)))</span><br><span class="line">[*] STORE: <span class="number">001008b</span>c (<span class="type">uint32_t</span>)(*(*(*(ARG0 + (<span class="type">const</span>, <span class="number">0x2</span>, <span class="number">8</span>) * (<span class="type">const</span>, <span class="number">0x4</span>, <span class="number">8</span>)) + (<span class="type">const</span>, <span class="number">0x10</span>, <span class="number">8</span>)) + (<span class="type">const</span>, <span class="number">0x4</span>, <span class="number">8</span>)))</span><br><span class="line">[*] STORE: <span class="number">001008</span>cf (<span class="type">uint32_t</span>)(*(*(*(ARG0 + (<span class="type">const</span>, <span class="number">0x2</span>, <span class="number">8</span>) * (<span class="type">const</span>, <span class="number">0x4</span>, <span class="number">8</span>)) + (<span class="type">const</span>, <span class="number">0x10</span>, <span class="number">8</span>)) + (<span class="type">const</span>, <span class="number">0x8</span>, <span class="number">8</span>)))</span><br><span class="line">[*] STORE: <span class="number">001008e2</span> (<span class="type">uint32_t</span>)(*(*(*(ARG0 + (<span class="type">const</span>, <span class="number">0x2</span>, <span class="number">8</span>) * (<span class="type">const</span>, <span class="number">0x4</span>, <span class="number">8</span>)) + (<span class="type">const</span>, <span class="number">0x10</span>, <span class="number">8</span>)) + (<span class="type">const</span>, <span class="number">0xc</span>, <span class="number">8</span>)))</span><br><span class="line">[*] STORE: <span class="number">001008f</span>5 (<span class="type">uint8_t</span>)(*(*(*(ARG0 + (<span class="type">const</span>, <span class="number">0x2</span>, <span class="number">8</span>) * (<span class="type">const</span>, <span class="number">0x4</span>, <span class="number">8</span>)) + (<span class="type">const</span>, <span class="number">0x10</span>, <span class="number">8</span>))))</span><br></pre></td></tr></table></figure>

<h2 id="Struct-Interpolation"><a href="#Struct-Interpolation" class="headerlink" title="Struct Interpolation"></a>Struct Interpolation</h2><p>The next step is to interpolate the structs based on these loads and stores. A <code>Struct</code> is defined as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">	self.size = size <span class="comment"># Total size of the struct</span></span><br><span class="line">	self.members = [(<span class="number">0</span>, <span class="number">1</span>)] * size <span class="comment"># Represents member (value, member_size)</span></span><br><span class="line">	self.marked = [<span class="literal">False</span>] * size <span class="comment"># Marked represents offsets in the struct that are accessed</span></span><br><span class="line">	self.is_array = <span class="literal">False</span></span><br><span class="line">	<span class="keyword">global</span> struct_counter</span><br><span class="line">	self.name = <span class="string">&quot;S&#123;&#125;&quot;</span>.<span class="built_in">format</span>(struct_counter)</span><br><span class="line">	struct_counter += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>It is simple in theory to interpolate the struct. If a (struct, offset, size) is dereferenced or loaded, we know that value is a pointer to either a primitive, struct, or array. Now we just have to implement traversing this recursively and interpolating members recursively, so that we can support arbitrary structures. This is implemented through the <code>create_struct</code> function for a <code>Node</code>.</p>
<p>Now here is the last issue: how do we know whether a struct dereference is a struct, array, or primitive? Differentiating between a primitive and a struct is quite easy, since a struct would contain dereferences, whereas a primitive would not. However, differentiating between a struct and an array is a more difficult problem. Both a struct and an array contain dereferences.</p>
<p>The solution I came up with, which may not be the best, is to use the idea of loop variants. Intuitively, we know that if we have an array, then we will be looping over the array at some point in the function. Thus, there must exist a loop - and when there is a loop, there are phi-nodes. The counter to this loop must be one of the nodes at a <code>MULTIEQUAL</code> instruction. These varnodes are loop variants. So, if we run forwards analysis twice, however on the second run, we define initial conditions for each loop variant varnodes encountered, then the values added during the second run would be the second iteration of the loop. If there exists an array, then on the second iteration, there would be extra <code>STORE</code> or <code>LOAD</code> expressions that was not seen on the first analysis run.</p>
<p>This method works well in the presence of loops which iterate through the array starting from index 0. However, we have to consider the case where iteration begins at an offset, and the case where only a single array index is accessed.</p>
<p>In the first case, there is somewhat of a grey line between if this would be a struct or array. If no other members exist prior to iteration offset, then it is likely an array. However, if there are unaligned or varying sized access, then it is likely a struct.</p>
<p>In the second case, based on the information available (a single index access), this case would best represent a struct rather than an array, based on what we as reverse engineers can see.</p>
<p>Finally, once structs are interpolated, we can use Ghidra’s API to automatically define these inferred structs in Ghidra’s DataTypeManager and retype function parameters.</p>
<h1 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h1><p>The following is a custom-made toy program with the following structs:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> haha;</span><br><span class="line">	<span class="type">int</span> L;</span><br><span class="line">	<span class="type">int</span> L2;</span><br><span class="line">	<span class="type">int</span> L3;</span><br><span class="line">&#125; dec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* buf;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">	dec2* lol;</span><br><span class="line">	dec2* lol2;</span><br><span class="line">&#125; dec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> return_code;</span><br><span class="line">  <span class="type">int</span> return_value;</span><br><span class="line">  dec* buf;</span><br><span class="line">&#125; hack;</span><br></pre></td></tr></table></figure>

<p>The Ghidra decompilation of one of the functions before running the plugin is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ulong <span class="title function_">atoi32</span><span class="params">(undefined4 *param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> local_1c;</span><br><span class="line">  <span class="type">char</span> *local_18;</span><br><span class="line">  </span><br><span class="line">  param_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  local_18 = **(<span class="type">char</span> ***)(param_1 + <span class="number">2</span>);</span><br><span class="line">  *(undefined4 *)(*(<span class="type">long</span> *)(*(<span class="type">long</span> *)(param_1 + <span class="number">2</span>) + <span class="number">0x10</span>) + <span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">  *(undefined4 *)(*(<span class="type">long</span> *)(*(<span class="type">long</span> *)(param_1 + <span class="number">2</span>) + <span class="number">0x10</span>) + <span class="number">8</span>) = <span class="number">2</span>;</span><br><span class="line">  *(undefined4 *)(*(<span class="type">long</span> *)(*(<span class="type">long</span> *)(param_1 + <span class="number">2</span>) + <span class="number">0x10</span>) + <span class="number">0xc</span>) = <span class="number">3</span>;</span><br><span class="line">  **(undefined **)(*(<span class="type">long</span> *)(param_1 + <span class="number">2</span>) + <span class="number">0x10</span>) = <span class="number">0x41</span>;</span><br><span class="line">  *(undefined4 *)(*(<span class="type">long</span> *)(*(<span class="type">long</span> *)(param_1 + <span class="number">2</span>) + <span class="number">0x18</span>) + <span class="number">4</span>) = <span class="number">4</span>;</span><br><span class="line">  *(undefined4 *)(*(<span class="type">long</span> *)(*(<span class="type">long</span> *)(param_1 + <span class="number">2</span>) + <span class="number">0x18</span>) + <span class="number">8</span>) = <span class="number">5</span>;</span><br><span class="line">  *(undefined4 *)(*(<span class="type">long</span> *)(*(<span class="type">long</span> *)(param_1 + <span class="number">2</span>) + <span class="number">0x18</span>) + <span class="number">0xc</span>) = <span class="number">6</span>;</span><br><span class="line">  **(undefined **)(*(<span class="type">long</span> *)(param_1 + <span class="number">2</span>) + <span class="number">0x18</span>) = <span class="number">0x42</span>;</span><br><span class="line">  local_1c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)(*(<span class="type">long</span> *)(param_1 + <span class="number">2</span>) + <span class="number">8</span>) &lt;= local_1c) &#123;</span><br><span class="line">      *param_1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">int</span>)param_1[<span class="number">1</span>] &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        uRam0000000000000000 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (ulong)(uint)param_1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*local_18 &lt; <span class="string">&#x27;0&#x27;</span>) || (<span class="string">&#x27;9&#x27;</span> &lt; *local_18)) <span class="keyword">break</span>;</span><br><span class="line">    param_1[<span class="number">1</span>] = param_1[<span class="number">1</span>] * <span class="number">10</span> + (<span class="type">int</span>)*local_18 + <span class="number">-0x30</span>;</span><br><span class="line">    local_18 = local_18 + <span class="number">1</span>;</span><br><span class="line">    local_1c = local_1c + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *param_1 = <span class="number">0xffffffff</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>After running the plugin:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ulong <span class="title function_">atoi32</span><span class="params">(S0 *param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> local_1c;</span><br><span class="line">  S4 *local_18;</span><br><span class="line">  </span><br><span class="line">  param_1-&gt;entry_1 = <span class="number">0</span>;</span><br><span class="line">  local_18 = param_1-&gt;entry_2-&gt;entry_0;</span><br><span class="line">  param_1-&gt;entry_2-&gt;entry_3-&gt;entry_2 = <span class="number">1</span>;</span><br><span class="line">  param_1-&gt;entry_2-&gt;entry_3-&gt;entry_3 = <span class="number">2</span>;</span><br><span class="line">  param_1-&gt;entry_2-&gt;entry_3-&gt;entry_4 = <span class="number">3</span>;</span><br><span class="line">  param_1-&gt;entry_2-&gt;entry_3-&gt;entry_0 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  param_1-&gt;entry_2-&gt;entry_4-&gt;entry_2 = <span class="number">4</span>;</span><br><span class="line">  param_1-&gt;entry_2-&gt;entry_4-&gt;entry_3 = <span class="number">5</span>;</span><br><span class="line">  param_1-&gt;entry_2-&gt;entry_4-&gt;entry_4 = <span class="number">6</span>;</span><br><span class="line">  param_1-&gt;entry_2-&gt;entry_4-&gt;entry_0 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">  local_1c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (param_1-&gt;entry_2-&gt;entry_1 &lt;= local_1c) &#123;</span><br><span class="line">      param_1-&gt;entry_0 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (param_1-&gt;entry_1 &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        uRam0000000000000000 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (ulong)(uint)param_1-&gt;entry_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((local_18-&gt;entry_0 &lt; <span class="string">&#x27;0&#x27;</span>) || (<span class="string">&#x27;9&#x27;</span> &lt; local_18-&gt;entry_0)) <span class="keyword">break</span>;</span><br><span class="line">    param_1-&gt;entry_1 = param_1-&gt;entry_1 * <span class="number">10</span> + (<span class="type">int</span>)local_18-&gt;entry_0 + <span class="number">-0x30</span>;</span><br><span class="line">    local_18 = local_18 + <span class="number">1</span>;</span><br><span class="line">    local_1c = local_1c + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  param_1-&gt;entry_0 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The recovered structs are:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> entry_0;</span><br><span class="line">	<span class="type">char</span> entry_1[<span class="number">3</span>]; <span class="comment">//NOT ACCESSED</span></span><br><span class="line">	<span class="type">uint32_t</span> entry_2;</span><br><span class="line">	<span class="type">uint32_t</span> entry_3;</span><br><span class="line">	<span class="type">uint32_t</span> entry_4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> entry_0;</span><br><span class="line">	<span class="type">char</span> entry_1[<span class="number">3</span>]; <span class="comment">//NOT ACCESSED</span></span><br><span class="line">	<span class="type">uint32_t</span> entry_2;</span><br><span class="line">	<span class="type">uint32_t</span> entry_3;</span><br><span class="line">	<span class="type">uint32_t</span> entry_4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span>* entry_0;</span><br><span class="line">	<span class="type">uint32_t</span> entry_1;</span><br><span class="line">	<span class="type">uint32_t</span> entry_2; <span class="comment">//NOT ACCESSED</span></span><br><span class="line">	S2* entry_3;</span><br><span class="line">	S3* entry_4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S0</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> entry_0;</span><br><span class="line">	<span class="type">uint32_t</span> entry_1;</span><br><span class="line">	S1* entry_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Incredibly accurate results. However, this is a custom test case, which may not be very convincing. Let’s try this on something more practical. During the Hack-A-Sat CTF 2020, I worked on a completely stripped MIPS firmware reversing+pwn challenge, which involved a large number of complex structs. The writeup for that task can be found <a target="_blank" rel="noopener" href="https://voido.cc/2020/06/01/Hack-A-Sat-CTF-2020-Launch-Link/">here</a>. This was a little endian MIPS binary, which is a great test case to demonstrate the flexibility of this code to work with all architectures. Through many hours of manual reverse engineering, one of the structs I ended up with is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mac_struct</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> absolute_max_length;</span><br><span class="line">	<span class="type">uint32_t</span> minimum_size;</span><br><span class="line">	<span class="type">uint32_t</span> initial_block_size;</span><br><span class="line">	<span class="type">uint32_t</span> op1;</span><br><span class="line">	<span class="type">uint32_t</span> op2;</span><br><span class="line">	<span class="type">uint32_t</span> op3;</span><br><span class="line">	<span class="type">uint32_t</span> a;</span><br><span class="line">	<span class="type">uint32_t</span> b;</span><br><span class="line">	<span class="type">uint32_t</span> c;</span><br><span class="line">	<span class="type">uint32_t</span> d;</span><br><span class="line">	<span class="type">uint32_t</span> id_maybe;</span><br><span class="line">	<span class="type">uint32_t</span> biggest_length;</span><br><span class="line">	<span class="type">uint32_t</span> global_data_buf;</span><br><span class="line">	<span class="type">uint32_t</span> linked_list1;</span><br><span class="line">	<span class="type">uint32_t</span> receive_linked_list;</span><br><span class="line">	<span class="type">uint32_t</span> linked_list5;</span><br><span class="line">	<span class="type">char</span>[<span class="number">384</span>] databuf;</span><br><span class="line">	<span class="type">uint16_t</span> buffer_length;</span><br><span class="line">	<span class="type">char</span> max_length;</span><br><span class="line">	<span class="type">char</span> e;</span><br><span class="line">	<span class="type">uint32_t</span> counter;</span><br><span class="line">	<span class="type">char</span> init_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Running the plugin, the generated struct we get is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S0</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> entry_0;</span><br><span class="line">	<span class="type">uint32_t</span> entry_1;</span><br><span class="line">	<span class="type">uint32_t</span> entry_2;</span><br><span class="line">	<span class="type">uint32_t</span> entry_3;</span><br><span class="line">	<span class="type">uint32_t</span> entry_4;</span><br><span class="line">	<span class="type">uint32_t</span> entry_5;</span><br><span class="line">	<span class="type">uint64_t</span> entry_6; <span class="comment">//NOT ACCESSED</span></span><br><span class="line">	<span class="type">uint32_t</span> entry_7;</span><br><span class="line">	<span class="type">uint32_t</span> entry_8; <span class="comment">//NOT ACCESSED</span></span><br><span class="line">	<span class="type">uint32_t</span> entry_9;</span><br><span class="line">	<span class="type">uint32_t</span> entry_10;</span><br><span class="line">	S3* entry_11;</span><br><span class="line">	S1* entry_12;</span><br><span class="line">	S4* entry_13;</span><br><span class="line">	<span class="type">uint32_t</span> entry_14; <span class="comment">//NOT ACCESSED</span></span><br><span class="line">	<span class="type">char</span> entry_15;</span><br><span class="line">	<span class="type">uint16_t</span> entry_16;</span><br><span class="line">	<span class="type">char</span> entry_17;</span><br><span class="line">	<span class="type">char</span> entry_18[<span class="number">380</span>]; <span class="comment">//NOT ACCESSED</span></span><br><span class="line">	<span class="type">uint16_t</span> entry_19;</span><br><span class="line">	<span class="type">char</span> entry_20;</span><br><span class="line">	<span class="type">char</span> entry_21; <span class="comment">//NOT ACCESSED</span></span><br><span class="line">	<span class="type">uint32_t</span> entry_22;</span><br><span class="line">	<span class="type">char</span> entry_23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Amazing results! The struct size is entirely the same, and the auto-generated struct is actually more accurate than the one I ended up with through manual reverse engineering.</p>
<h1 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h1><p>One of the issues I encountered is that while performing analysis on a function, all of the call signatures for the functions must be accurate in order for the parameters in Ghidra’s P-Code analysis to be consistent with the function signatures. This can most likely be automated through Ghidra’s API, as it allows re-typing function signatures.</p>
<p>Another issue that remains is that sometimes arrays identification may still be inaccurate at times - however further testing will be required. One of these issues include identifying array buffers as a struct member by itself, as opposed to simply identifying array pointers. Another issue is when arrays store double pointers, such as a <code>char** array</code>.</p>
<p>One big issue that is not easily solvable is when there are duplicate structs. Currently, two different structs will be defined even if the same struct is used in multiple places. A “hack” to fix this would be to inspect the final structs created, and if any of the struct’s signatures completely match, then mark those as duplicates. However, this may result in false positives.</p>
<p>A simple extension would be to allow the struct analysis of other function variables, instead of just function parameters.</p>
<p>Finally, an nice feature to aid with reverse engineering would be to allow cross references for a struct’s members after automatically committing the type changes everywhere the type is propogated to during forward analysis.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Overall, I really enjoyed working on this project. I not only learned about how Ghidra works in the backend, but also gained a deep understanding of how symbolic analysis and data dependence works fundamentally. Re-creating something from scratch really is the best way to learn and demonstrate full understanding of a concept. I think the end result is pretty amazing, and is something I would actually use while reverse engineering binaries during CTFs.</p>

        
    </section>
</article>




            </div>
        </div>

        
            
            <a id="pagenext" href="/2020/06/01/Hack-A-Sat-CTF-2020-Launch-Link/" class="article-next" title="Hack-A-Sat CTF 2020 - Launch Link"><i class="icon-arrow-right"></i></a>
            
            
            <a id="pageprev" href="/2023/12/06/Reflecting-On-Learning-As-Resolving-Uncertainty/" class="article-prev" title="Reflecting On Learning As Resolving Uncertainty"><i class="icon-arrow-left"></i></a>
            
        

        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    
        
<script src="/js/scrollspy.min.js"></script>

        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                pageprev.css($.extend({left: hw + len}, styles));
                pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
